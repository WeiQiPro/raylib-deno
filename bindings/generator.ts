let result = "// This file is generated by generator.ts\n\n";
const source = Deno.readTextFileSync("./raylib.h").split("\n");

// Generate the version constants
result += `// --- Version constants ---\n`
result += `export const RAYLIB_VERSION_MAJOR = ${source[83].split(" ").pop()};\n`
result += `export const RAYLIB_VERSION_MINOR = ${source[84].split(" ").pop()};\n`
result += `export const RAYLIB_VERSION_PATCH = ${source[85].split(" ").pop()};\n`
result += `export const RAYLIB_VERSION = ${source[86].split(" ").pop()};\n\n`

// Generate the color constants
result += `// --- Color constants ---\n`

for(let i = 163; i < 190; i++) {
  if(source[i].trim() === "") continue;
  const values = source[i].replaceAll(",", "").split(" ").filter((v) => v !== "");
  const name = values[1];
  const red = values[3];
  const green = values[4];
  const blue = values[5];
  const alpha = values[6];

  result += `export const ${name} = new Uint8Array([${blue}, ${green}, ${red}, ${alpha}]);\n`
}

result += "\n";

// TODO: Generate struct definitions
// TODO: Generate enum definitions

// Generate the function definitions
result += "// --- bindings ---\n";
result += 'import { dlopen } from "https://deno.land/x/plug@1.0.3/mod.ts";\n\n';
result += 'export const lib = await dlopen({\n\tname: "raylib",\n\turl: import.meta.resolve("../blobs")\n}, {\n'

function extract(core: string) {
  return {
    name: core.split(" ").pop()!.slice(core.split("*").length - 1),
    type: core.split(" ").slice(0, -1).join(" ") + (core.split("*").length > 1 ? " " + new Array(core.split("*").length - 1).fill("*").join("") : "")
  }
}

const raw_type_map: Record<string, unknown> = {
  "void": "void",
  "void *": "pointer",
  "bool": "u8",
  "char": "i8",
  "unsigned int": "u32",
  "int": "i32",
  "long": "i64",
  "int *": "pointer",
  "const int *": "pointer",
  "const char *": "buffer",
  "const char **": "buffer",
  "unsigned char *": "buffer",
  "const unsigned char *": "buffer",
  "const void *": "buffer",
  "char *": "buffer",
  "float *": "buffer",
  "float": "f32",
  "double": "f64",
  // Custom types
  "const Matrix *": "buffer",
  "Color": { struct: ["u8", "u8","u8","u8"]},
  "Image": "buffer",
  "Font": "buffer",
  "Rectangle": "buffer",
  "BoundingBox": "buffer",
  "Matrix": "buffer",
  "Vector2": "buffer",
  "Vector3": "buffer",
  "Vector4": "buffer",
  "Ray": "buffer",
  "RayCollision": "buffer",
  "Model": "buffer",
  "Mesh": "buffer",
  "Material": "buffer",
  "ModelAnimation": "buffer",
  "Texture2D": "buffer",
  "TextureCubemap": "buffer",
  "RenderTexture2D": "buffer",
  "Camera": "buffer",
  "Camera2D": "buffer",
  "Camera3D": "buffer",
  "Shader": "buffer",
  "Sound": "buffer",
  "Wave": "buffer",
  "Music": "buffer",
  "AudioStream": "buffer",
  "FilePathList": "buffer",
  "AutomationEvent": "buffer",
  "AutomationEventList": "buffer",
  "NPatchInfo": "buffer",
  "GlyphInfo": "buffer",
  "VrStereoConfig": "buffer",
  "VrDeviceInfo": "buffer",
  // Custom types pointers,
  "Color *": "pointer",
  "Image *": "pointer",
  "Vector2 *": "pointer",
  "Vector3 *": "pointer",
  "Wave *": "pointer",
  "ModelAnimation *": "pointer",
  "Mesh *": "pointer",
  "Model *": "pointer",
  "Material *": "pointer",
  "Camera *": "pointer",
  "AutomationEventList *": "pointer",
  "Texture2D *": "pointer",
  "GlyphInfo *": "pointer",
  "const GlyphInfo *": "pointer",
  "Rectangle **": "pointer",
  // Function pointers
  "AudioCallback": "function",
  "TraceLogCallback": "function",
  "LoadFileDataCallback": "function",
  "SaveFileDataCallback": "function",
  "LoadFileTextCallback": "function",
  "SaveFileTextCallback": "function",
};

let functions = "// --- functions ---\n";

for(let i = 953; i < 1656; i++) {
  if(!source[i].startsWith("RLAPI")) continue;
  if(source[i].includes("...")) continue;
  const comment = source[i].split("//")[1].trim();
  const { name: functionName, type: returnType } = extract(source[i].split("(")[0].split(" ").slice(1).join(" "));
  const parameters = source[i].split("(")[1].split(")")[0] === "void" ? [] : source[i].split("(")[1].split(")")[0].split(",").map((v) => extract(v.trim()));

  result += `\t// ${comment}\n`;
  result += `\t${functionName}: { parameters: [${parameters.map((param) => JSON.stringify(raw_type_map[param.type])).join(", ")}], result: ${JSON.stringify(raw_type_map[returnType])} },\n`;
}

result += "});\n\n";

// Write the result to the bindings file
Deno.writeTextFileSync("./bindings.ts", result);
