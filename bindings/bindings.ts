// This file is generated by generator.ts

// --- Version constants ---
export const RAYLIB_VERSION_MAJOR = 5;
export const RAYLIB_VERSION_MINOR = 0;
export const RAYLIB_VERSION_PATCH = 0;
export const RAYLIB_VERSION = "5.0";

// --- Color constants ---
export const LIGHTGRAY = new Uint8Array([200, 200, 200, 255]);
export const GRAY = new Uint8Array([130, 130, 130, 255]);
export const DARKGRAY = new Uint8Array([80, 80, 80, 255]);
export const YELLOW = new Uint8Array([0, 249, 253, 255]);
export const GOLD = new Uint8Array([0, 203, 255, 255]);
export const ORANGE = new Uint8Array([0, 161, 255, 255]);
export const PINK = new Uint8Array([194, 109, 255, 255]);
export const RED = new Uint8Array([55, 41, 230, 255]);
export const MAROON = new Uint8Array([55, 33, 190, 255]);
export const GREEN = new Uint8Array([48, 228, 0, 255]);
export const LIME = new Uint8Array([47, 158, 0, 255]);
export const DARKGREEN = new Uint8Array([44, 117, 0, 255]);
export const SKYBLUE = new Uint8Array([255, 191, 102, 255]);
export const BLUE = new Uint8Array([241, 121, 0, 255]);
export const DARKBLUE = new Uint8Array([172, 82, 0, 255]);
export const PURPLE = new Uint8Array([255, 122, 200, 255]);
export const VIOLET = new Uint8Array([190, 60, 135, 255]);
export const DARKPURPLE = new Uint8Array([126, 31, 112, 255]);
export const BEIGE = new Uint8Array([131, 176, 211, 255]);
export const BROWN = new Uint8Array([79, 106, 127, 255]);
export const DARKBROWN = new Uint8Array([47, 63, 76, 255]);
export const WHITE = new Uint8Array([255, 255, 255, 255]);
export const BLACK = new Uint8Array([0, 0, 0, 255]);
export const BLANK = new Uint8Array([0, 0, 0, 0]);
export const MAGENTA = new Uint8Array([255, 0, 255, 255]);
export const RAYWHITE = new Uint8Array([245, 245, 245, 255]);

// --- bindings ---
import { dlopen } from "https://deno.land/x/plug@1.0.3/mod.ts";

export const lib = await dlopen({
	name: "raylib",
	url: import.meta.resolve("../blobs")
}, {
	// Initialize window and OpenGL context
	InitWindow: { parameters: ["i32", "i32", "buffer"], result: "void" },
	// Close window and unload OpenGL context
	CloseWindow: { parameters: [], result: "void" },
	// Check if application should close (KEY_ESCAPE pressed or windows close icon clicked)
	WindowShouldClose: { parameters: [], result: "u8" },
	// Check if window has been initialized successfully
	IsWindowReady: { parameters: [], result: "u8" },
	// Check if window is currently fullscreen
	IsWindowFullscreen: { parameters: [], result: "u8" },
	// Check if window is currently hidden (only PLATFORM_DESKTOP)
	IsWindowHidden: { parameters: [], result: "u8" },
	// Check if window is currently minimized (only PLATFORM_DESKTOP)
	IsWindowMinimized: { parameters: [], result: "u8" },
	// Check if window is currently maximized (only PLATFORM_DESKTOP)
	IsWindowMaximized: { parameters: [], result: "u8" },
	// Check if window is currently focused (only PLATFORM_DESKTOP)
	IsWindowFocused: { parameters: [], result: "u8" },
	// Check if window has been resized last frame
	IsWindowResized: { parameters: [], result: "u8" },
	// Check if one specific window flag is enabled
	IsWindowState: { parameters: ["u32"], result: "u8" },
	// Set window configuration state using flags (only PLATFORM_DESKTOP)
	SetWindowState: { parameters: ["u32"], result: "void" },
	// Clear window configuration state flags
	ClearWindowState: { parameters: ["u32"], result: "void" },
	// Toggle window state: fullscreen/windowed (only PLATFORM_DESKTOP)
	ToggleFullscreen: { parameters: [], result: "void" },
	// Toggle window state: borderless windowed (only PLATFORM_DESKTOP)
	ToggleBorderlessWindowed: { parameters: [], result: "void" },
	// Set window state: maximized, if resizable (only PLATFORM_DESKTOP)
	MaximizeWindow: { parameters: [], result: "void" },
	// Set window state: minimized, if resizable (only PLATFORM_DESKTOP)
	MinimizeWindow: { parameters: [], result: "void" },
	// Set window state: not minimized/maximized (only PLATFORM_DESKTOP)
	RestoreWindow: { parameters: [], result: "void" },
	// Set icon for window (single image, RGBA 32bit, only PLATFORM_DESKTOP)
	SetWindowIcon: { parameters: ["buffer"], result: "void" },
	// Set icon for window (multiple images, RGBA 32bit, only PLATFORM_DESKTOP)
	SetWindowIcons: { parameters: ["pointer", "i32"], result: "void" },
	// Set title for window (only PLATFORM_DESKTOP and PLATFORM_WEB)
	SetWindowTitle: { parameters: ["buffer"], result: "void" },
	// Set window position on screen (only PLATFORM_DESKTOP)
	SetWindowPosition: { parameters: ["i32", "i32"], result: "void" },
	// Set monitor for the current window
	SetWindowMonitor: { parameters: ["i32"], result: "void" },
	// Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)
	SetWindowMinSize: { parameters: ["i32", "i32"], result: "void" },
	// Set window maximum dimensions (for FLAG_WINDOW_RESIZABLE)
	SetWindowMaxSize: { parameters: ["i32", "i32"], result: "void" },
	// Set window dimensions
	SetWindowSize: { parameters: ["i32", "i32"], result: "void" },
	// Set window opacity [0.0f..1.0f] (only PLATFORM_DESKTOP)
	SetWindowOpacity: { parameters: ["f32"], result: "void" },
	// Set window focused (only PLATFORM_DESKTOP)
	SetWindowFocused: { parameters: [], result: "void" },
	// Get native window handle
	GetWindowHandle: { parameters: [], result: "pointer" },
	// Get current screen width
	GetScreenWidth: { parameters: [], result: "i32" },
	// Get current screen height
	GetScreenHeight: { parameters: [], result: "i32" },
	// Get current render width (it considers HiDPI)
	GetRenderWidth: { parameters: [], result: "i32" },
	// Get current render height (it considers HiDPI)
	GetRenderHeight: { parameters: [], result: "i32" },
	// Get number of connected monitors
	GetMonitorCount: { parameters: [], result: "i32" },
	// Get current connected monitor
	GetCurrentMonitor: { parameters: [], result: "i32" },
	// Get specified monitor position
	GetMonitorPosition: { parameters: ["i32"], result: "buffer" },
	// Get specified monitor width (current video mode used by monitor)
	GetMonitorWidth: { parameters: ["i32"], result: "i32" },
	// Get specified monitor height (current video mode used by monitor)
	GetMonitorHeight: { parameters: ["i32"], result: "i32" },
	// Get specified monitor physical width in millimetres
	GetMonitorPhysicalWidth: { parameters: ["i32"], result: "i32" },
	// Get specified monitor physical height in millimetres
	GetMonitorPhysicalHeight: { parameters: ["i32"], result: "i32" },
	// Get specified monitor refresh rate
	GetMonitorRefreshRate: { parameters: ["i32"], result: "i32" },
	// Get window position XY on monitor
	GetWindowPosition: { parameters: [], result: "buffer" },
	// Get window scale DPI factor
	GetWindowScaleDPI: { parameters: [], result: "buffer" },
	// Get the human-readable, UTF-8 encoded name of the specified monitor
	GetMonitorName: { parameters: ["i32"], result: "buffer" },
	// Set clipboard text content
	SetClipboardText: { parameters: ["buffer"], result: "void" },
	// Get clipboard text content
	GetClipboardText: { parameters: [], result: "buffer" },
	// Enable waiting for events on EndDrawing(), no automatic event polling
	EnableEventWaiting: { parameters: [], result: "void" },
	// Disable waiting for events on EndDrawing(), automatic events polling
	DisableEventWaiting: { parameters: [], result: "void" },
	// Shows cursor
	ShowCursor: { parameters: [], result: "void" },
	// Hides cursor
	HideCursor: { parameters: [], result: "void" },
	// Check if cursor is not visible
	IsCursorHidden: { parameters: [], result: "u8" },
	// Enables cursor (unlock cursor)
	EnableCursor: { parameters: [], result: "void" },
	// Disables cursor (lock cursor)
	DisableCursor: { parameters: [], result: "void" },
	// Check if cursor is on the screen
	IsCursorOnScreen: { parameters: [], result: "u8" },
	// Set background color (framebuffer clear color)
	ClearBackground: { parameters: [{"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Setup canvas (framebuffer) to start drawing
	BeginDrawing: { parameters: [], result: "void" },
	// End canvas drawing and swap buffers (double buffering)
	EndDrawing: { parameters: [], result: "void" },
	// Begin 2D mode with custom camera (2D)
	BeginMode2D: { parameters: ["buffer"], result: "void" },
	// Ends 2D mode with custom camera
	EndMode2D: { parameters: [], result: "void" },
	// Begin 3D mode with custom camera (3D)
	BeginMode3D: { parameters: ["buffer"], result: "void" },
	// Ends 3D mode and returns to default 2D orthographic mode
	EndMode3D: { parameters: [], result: "void" },
	// Begin drawing to render texture
	BeginTextureMode: { parameters: ["buffer"], result: "void" },
	// Ends drawing to render texture
	EndTextureMode: { parameters: [], result: "void" },
	// Begin custom shader drawing
	BeginShaderMode: { parameters: ["buffer"], result: "void" },
	// End custom shader drawing (use default shader)
	EndShaderMode: { parameters: [], result: "void" },
	// Begin blending mode (alpha, additive, multiplied, subtract, custom)
	BeginBlendMode: { parameters: ["i32"], result: "void" },
	// End blending mode (reset to default: alpha blending)
	EndBlendMode: { parameters: [], result: "void" },
	// Begin scissor mode (define screen area for following drawing)
	BeginScissorMode: { parameters: ["i32", "i32", "i32", "i32"], result: "void" },
	// End scissor mode
	EndScissorMode: { parameters: [], result: "void" },
	// Begin stereo rendering (requires VR simulator)
	BeginVrStereoMode: { parameters: ["buffer"], result: "void" },
	// End stereo rendering (requires VR simulator)
	EndVrStereoMode: { parameters: [], result: "void" },
	// Load VR stereo config for VR simulator device parameters
	LoadVrStereoConfig: { parameters: ["buffer"], result: "buffer" },
	// Unload VR stereo config
	UnloadVrStereoConfig: { parameters: ["buffer"], result: "void" },
	// Load shader from files and bind default locations
	LoadShader: { parameters: ["buffer", "buffer"], result: "buffer" },
	// Load shader from code strings and bind default locations
	LoadShaderFromMemory: { parameters: ["buffer", "buffer"], result: "buffer" },
	// Check if a shader is ready
	IsShaderReady: { parameters: ["buffer"], result: "u8" },
	// Get shader uniform location
	GetShaderLocation: { parameters: ["buffer", "buffer"], result: "i32" },
	// Get shader attribute location
	GetShaderLocationAttrib: { parameters: ["buffer", "buffer"], result: "i32" },
	// Set shader uniform value
	SetShaderValue: { parameters: ["buffer", "i32", "buffer", "i32"], result: "void" },
	// Set shader uniform value vector
	SetShaderValueV: { parameters: ["buffer", "i32", "buffer", "i32", "i32"], result: "void" },
	// Set shader uniform value (matrix 4x4)
	SetShaderValueMatrix: { parameters: ["buffer", "i32", "buffer"], result: "void" },
	// Set shader uniform value for texture (sampler2d)
	SetShaderValueTexture: { parameters: ["buffer", "i32", "buffer"], result: "void" },
	// Unload shader from GPU memory (VRAM)
	UnloadShader: { parameters: ["buffer"], result: "void" },
	// Get a ray trace from mouse position
	GetMouseRay: { parameters: ["buffer", "buffer"], result: "buffer" },
	// Get camera transform matrix (view matrix)
	GetCameraMatrix: { parameters: ["buffer"], result: "buffer" },
	// Get camera 2d transform matrix
	GetCameraMatrix2D: { parameters: ["buffer"], result: "buffer" },
	// Get the screen space position for a 3d world space position
	GetWorldToScreen: { parameters: ["buffer", "buffer"], result: "buffer" },
	// Get the world space position for a 2d camera screen space position
	GetScreenToWorld2D: { parameters: ["buffer", "buffer"], result: "buffer" },
	// Get size position for a 3d world space position
	GetWorldToScreenEx: { parameters: ["buffer", "buffer", "i32", "i32"], result: "buffer" },
	// Get the screen space position for a 2d camera world space position
	GetWorldToScreen2D: { parameters: ["buffer", "buffer"], result: "buffer" },
	// Set target FPS (maximum)
	SetTargetFPS: { parameters: ["i32"], result: "void" },
	// Get time in seconds for last frame drawn (delta time)
	GetFrameTime: { parameters: [], result: "f32" },
	// Get elapsed time in seconds since InitWindow()
	GetTime: { parameters: [], result: "f64" },
	// Get current FPS
	GetFPS: { parameters: [], result: "i32" },
	// Swap back buffer with front buffer (screen drawing)
	SwapScreenBuffer: { parameters: [], result: "void" },
	// Register all input events
	PollInputEvents: { parameters: [], result: "void" },
	// Wait for some time (halt program execution)
	WaitTime: { parameters: ["f64"], result: "void" },
	// Set the seed for the random number generator
	SetRandomSeed: { parameters: ["u32"], result: "void" },
	// Get a random value between min and max (both included)
	GetRandomValue: { parameters: ["i32", "i32"], result: "i32" },
	// Load random values sequence, no values repeated
	LoadRandomSequence: { parameters: ["u32", "i32", "i32"], result: "pointer" },
	// Unload random values sequence
	UnloadRandomSequence: { parameters: ["pointer"], result: "void" },
	// Takes a screenshot of current screen (filename extension defines format)
	TakeScreenshot: { parameters: ["buffer"], result: "void" },
	// Setup init configuration flags (view FLAGS)
	SetConfigFlags: { parameters: ["u32"], result: "void" },
	// Open URL with default system browser (if available)
	OpenURL: { parameters: ["buffer"], result: "void" },
	// Set the current threshold (minimum) log level
	SetTraceLogLevel: { parameters: ["i32"], result: "void" },
	// Internal memory allocator
	MemAlloc: { parameters: ["u32"], result: "pointer" },
	// Internal memory reallocator
	MemRealloc: { parameters: ["pointer", "u32"], result: "pointer" },
	// Internal memory free
	MemFree: { parameters: ["pointer"], result: "void" },
	// Set custom trace log
	SetTraceLogCallback: { parameters: ["function"], result: "void" },
	// Set custom file binary data loader
	SetLoadFileDataCallback: { parameters: ["function"], result: "void" },
	// Set custom file binary data saver
	SetSaveFileDataCallback: { parameters: ["function"], result: "void" },
	// Set custom file text data loader
	SetLoadFileTextCallback: { parameters: ["function"], result: "void" },
	// Set custom file text data saver
	SetSaveFileTextCallback: { parameters: ["function"], result: "void" },
	// Load file data as byte array (read)
	LoadFileData: { parameters: ["buffer", "pointer"], result: "buffer" },
	// Unload file data allocated by LoadFileData()
	UnloadFileData: { parameters: ["buffer"], result: "void" },
	// Save data to file from byte array (write), returns true on success
	SaveFileData: { parameters: ["buffer", "pointer", "i32"], result: "u8" },
	// Export data to code (.h), returns true on success
	ExportDataAsCode: { parameters: ["buffer", "i32", "buffer"], result: "u8" },
	// Load text data from file (read), returns a '\0' terminated string
	LoadFileText: { parameters: ["buffer"], result: "buffer" },
	// Unload file text data allocated by LoadFileText()
	UnloadFileText: { parameters: ["buffer"], result: "void" },
	// Save text data to file (write), string must be '\0' terminated, returns true on success
	SaveFileText: { parameters: ["buffer", "buffer"], result: "u8" },
	// Check if file exists
	FileExists: { parameters: ["buffer"], result: "u8" },
	// Check if a directory path exists
	DirectoryExists: { parameters: ["buffer"], result: "u8" },
	// Check file extension (including point: .png, .wav)
	IsFileExtension: { parameters: ["buffer", "buffer"], result: "u8" },
	// Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)
	GetFileLength: { parameters: ["buffer"], result: "i32" },
	// Get pointer to extension for a filename string (includes dot: '.png')
	GetFileExtension: { parameters: ["buffer"], result: "buffer" },
	// Get pointer to filename for a path string
	GetFileName: { parameters: ["buffer"], result: "buffer" },
	// Get filename string without extension (uses static string)
	GetFileNameWithoutExt: { parameters: ["buffer"], result: "buffer" },
	// Get full path for a given fileName with path (uses static string)
	GetDirectoryPath: { parameters: ["buffer"], result: "buffer" },
	// Get previous directory path for a given path (uses static string)
	GetPrevDirectoryPath: { parameters: ["buffer"], result: "buffer" },
	// Get current working directory (uses static string)
	GetWorkingDirectory: { parameters: [], result: "buffer" },
	// Get the directory of the running application (uses static string)
	GetApplicationDirectory: { parameters: [], result: "buffer" },
	// Change working directory, return true on success
	ChangeDirectory: { parameters: ["buffer"], result: "u8" },
	// Check if a given path is a file or a directory
	IsPathFile: { parameters: ["buffer"], result: "u8" },
	// Load directory filepaths
	LoadDirectoryFiles: { parameters: ["buffer"], result: "buffer" },
	// Load directory filepaths with extension filtering and recursive directory scan
	LoadDirectoryFilesEx: { parameters: ["buffer", "buffer", "u8"], result: "buffer" },
	// Unload filepaths
	UnloadDirectoryFiles: { parameters: ["buffer"], result: "void" },
	// Check if a file has been dropped into window
	IsFileDropped: { parameters: [], result: "u8" },
	// Load dropped filepaths
	LoadDroppedFiles: { parameters: [], result: "buffer" },
	// Unload dropped filepaths
	UnloadDroppedFiles: { parameters: ["buffer"], result: "void" },
	// Get file modification time (last write time)
	GetFileModTime: { parameters: ["buffer"], result: "i64" },
	// Compress data (DEFLATE algorithm), memory must be MemFree()
	CompressData: { parameters: ["buffer", "i32", "pointer"], result: "buffer" },
	// Decompress data (DEFLATE algorithm), memory must be MemFree()
	DecompressData: { parameters: ["buffer", "i32", "pointer"], result: "buffer" },
	// Encode data to Base64 string, memory must be MemFree()
	EncodeDataBase64: { parameters: ["buffer", "i32", "pointer"], result: "buffer" },
	// Decode Base64 string data, memory must be MemFree()
	DecodeDataBase64: { parameters: ["buffer", "pointer"], result: "buffer" },
	// Load automation events list from file, NULL for empty list, capacity = MAX_AUTOMATION_EVENTS
	LoadAutomationEventList: { parameters: ["buffer"], result: "buffer" },
	// Unload automation events list from file
	UnloadAutomationEventList: { parameters: ["pointer"], result: "void" },
	// Export automation events list as text file
	ExportAutomationEventList: { parameters: ["buffer", "buffer"], result: "u8" },
	// Set automation event list to record to
	SetAutomationEventList: { parameters: ["pointer"], result: "void" },
	// Set automation event internal base frame to start recording
	SetAutomationEventBaseFrame: { parameters: ["i32"], result: "void" },
	// Start recording automation events (AutomationEventList must be set)
	StartAutomationEventRecording: { parameters: [], result: "void" },
	// Stop recording automation events
	StopAutomationEventRecording: { parameters: [], result: "void" },
	// Play a recorded automation event
	PlayAutomationEvent: { parameters: ["buffer"], result: "void" },
	// Check if a key has been pressed once
	IsKeyPressed: { parameters: ["i32"], result: "u8" },
	// Check if a key has been pressed again (Only PLATFORM_DESKTOP)
	IsKeyPressedRepeat: { parameters: ["i32"], result: "u8" },
	// Check if a key is being pressed
	IsKeyDown: { parameters: ["i32"], result: "u8" },
	// Check if a key has been released once
	IsKeyReleased: { parameters: ["i32"], result: "u8" },
	// Check if a key is NOT being pressed
	IsKeyUp: { parameters: ["i32"], result: "u8" },
	// Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty
	GetKeyPressed: { parameters: [], result: "i32" },
	// Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty
	GetCharPressed: { parameters: [], result: "i32" },
	// Set a custom key to exit program (default is ESC)
	SetExitKey: { parameters: ["i32"], result: "void" },
	// Check if a gamepad is available
	IsGamepadAvailable: { parameters: ["i32"], result: "u8" },
	// Get gamepad internal name id
	GetGamepadName: { parameters: ["i32"], result: "buffer" },
	// Check if a gamepad button has been pressed once
	IsGamepadButtonPressed: { parameters: ["i32", "i32"], result: "u8" },
	// Check if a gamepad button is being pressed
	IsGamepadButtonDown: { parameters: ["i32", "i32"], result: "u8" },
	// Check if a gamepad button has been released once
	IsGamepadButtonReleased: { parameters: ["i32", "i32"], result: "u8" },
	// Check if a gamepad button is NOT being pressed
	IsGamepadButtonUp: { parameters: ["i32", "i32"], result: "u8" },
	// Get the last gamepad button pressed
	GetGamepadButtonPressed: { parameters: [], result: "i32" },
	// Get gamepad axis count for a gamepad
	GetGamepadAxisCount: { parameters: ["i32"], result: "i32" },
	// Get axis movement value for a gamepad axis
	GetGamepadAxisMovement: { parameters: ["i32", "i32"], result: "f32" },
	// Set internal gamepad mappings (SDL_GameControllerDB)
	SetGamepadMappings: { parameters: ["buffer"], result: "i32" },
	// Check if a mouse button has been pressed once
	IsMouseButtonPressed: { parameters: ["i32"], result: "u8" },
	// Check if a mouse button is being pressed
	IsMouseButtonDown: { parameters: ["i32"], result: "u8" },
	// Check if a mouse button has been released once
	IsMouseButtonReleased: { parameters: ["i32"], result: "u8" },
	// Check if a mouse button is NOT being pressed
	IsMouseButtonUp: { parameters: ["i32"], result: "u8" },
	// Get mouse position X
	GetMouseX: { parameters: [], result: "i32" },
	// Get mouse position Y
	GetMouseY: { parameters: [], result: "i32" },
	// Get mouse position XY
	GetMousePosition: { parameters: [], result: "buffer" },
	// Get mouse delta between frames
	GetMouseDelta: { parameters: [], result: "buffer" },
	// Set mouse position XY
	SetMousePosition: { parameters: ["i32", "i32"], result: "void" },
	// Set mouse offset
	SetMouseOffset: { parameters: ["i32", "i32"], result: "void" },
	// Set mouse scaling
	SetMouseScale: { parameters: ["f32", "f32"], result: "void" },
	// Get mouse wheel movement for X or Y, whichever is larger
	GetMouseWheelMove: { parameters: [], result: "f32" },
	// Get mouse wheel movement for both X and Y
	GetMouseWheelMoveV: { parameters: [], result: "buffer" },
	// Set mouse cursor
	SetMouseCursor: { parameters: ["i32"], result: "void" },
	// Get touch position X for touch point 0 (relative to screen size)
	GetTouchX: { parameters: [], result: "i32" },
	// Get touch position Y for touch point 0 (relative to screen size)
	GetTouchY: { parameters: [], result: "i32" },
	// Get touch position XY for a touch point index (relative to screen size)
	GetTouchPosition: { parameters: ["i32"], result: "buffer" },
	// Get touch point identifier for given index
	GetTouchPointId: { parameters: ["i32"], result: "i32" },
	// Get number of touch points
	GetTouchPointCount: { parameters: [], result: "i32" },
	// Enable a set of gestures using flags
	SetGesturesEnabled: { parameters: ["u32"], result: "void" },
	// Check if a gesture have been detected
	IsGestureDetected: { parameters: ["u32"], result: "u8" },
	// Get latest detected gesture
	GetGestureDetected: { parameters: [], result: "i32" },
	// Get gesture hold time in milliseconds
	GetGestureHoldDuration: { parameters: [], result: "f32" },
	// Get gesture drag vector
	GetGestureDragVector: { parameters: [], result: "buffer" },
	// Get gesture drag angle
	GetGestureDragAngle: { parameters: [], result: "f32" },
	// Get gesture pinch delta
	GetGesturePinchVector: { parameters: [], result: "buffer" },
	// Get gesture pinch angle
	GetGesturePinchAngle: { parameters: [], result: "f32" },
	// Update camera position for selected mode
	UpdateCamera: { parameters: ["pointer", "i32"], result: "void" },
	// Update camera movement/rotation
	UpdateCameraPro: { parameters: ["pointer", "buffer", "buffer", "f32"], result: "void" },
	// Set texture and rectangle to be used on shapes drawing
	SetShapesTexture: { parameters: ["buffer", "buffer"], result: "void" },
	// Draw a pixel
	DrawPixel: { parameters: ["i32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a pixel (Vector version)
	DrawPixelV: { parameters: ["buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a line
	DrawLine: { parameters: ["i32", "i32", "i32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a line (using gl lines)
	DrawLineV: { parameters: ["buffer", "buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a line (using triangles/quads)
	DrawLineEx: { parameters: ["buffer", "buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw lines sequence (using gl lines)
	DrawLineStrip: { parameters: ["pointer", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw line segment cubic-bezier in-out interpolation
	DrawLineBezier: { parameters: ["buffer", "buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a color-filled circle
	DrawCircle: { parameters: ["i32", "i32", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a piece of a circle
	DrawCircleSector: { parameters: ["buffer", "f32", "f32", "f32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw circle sector outline
	DrawCircleSectorLines: { parameters: ["buffer", "f32", "f32", "f32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a gradient-filled circle
	DrawCircleGradient: { parameters: ["i32", "i32", "f32", {"struct":["u8","u8","u8","u8"]}, {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a color-filled circle (Vector version)
	DrawCircleV: { parameters: ["buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw circle outline
	DrawCircleLines: { parameters: ["i32", "i32", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw circle outline (Vector version)
	DrawCircleLinesV: { parameters: ["buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw ellipse
	DrawEllipse: { parameters: ["i32", "i32", "f32", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw ellipse outline
	DrawEllipseLines: { parameters: ["i32", "i32", "f32", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw ring
	DrawRing: { parameters: ["buffer", "f32", "f32", "f32", "f32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw ring outline
	DrawRingLines: { parameters: ["buffer", "f32", "f32", "f32", "f32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a color-filled rectangle
	DrawRectangle: { parameters: ["i32", "i32", "i32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a color-filled rectangle (Vector version)
	DrawRectangleV: { parameters: ["buffer", "buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a color-filled rectangle
	DrawRectangleRec: { parameters: ["buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a color-filled rectangle with pro parameters
	DrawRectanglePro: { parameters: ["buffer", "buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a vertical-gradient-filled rectangle
	DrawRectangleGradientV: { parameters: ["i32", "i32", "i32", "i32", {"struct":["u8","u8","u8","u8"]}, {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a horizontal-gradient-filled rectangle
	DrawRectangleGradientH: { parameters: ["i32", "i32", "i32", "i32", {"struct":["u8","u8","u8","u8"]}, {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a gradient-filled rectangle with custom vertex colors
	DrawRectangleGradientEx: { parameters: ["buffer", {"struct":["u8","u8","u8","u8"]}, {"struct":["u8","u8","u8","u8"]}, {"struct":["u8","u8","u8","u8"]}, {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw rectangle outline
	DrawRectangleLines: { parameters: ["i32", "i32", "i32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw rectangle outline with extended parameters
	DrawRectangleLinesEx: { parameters: ["buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw rectangle with rounded edges
	DrawRectangleRounded: { parameters: ["buffer", "f32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw rectangle with rounded edges outline
	DrawRectangleRoundedLines: { parameters: ["buffer", "f32", "i32", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a color-filled triangle (vertex in counter-clockwise order!)
	DrawTriangle: { parameters: ["buffer", "buffer", "buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw triangle outline (vertex in counter-clockwise order!)
	DrawTriangleLines: { parameters: ["buffer", "buffer", "buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a triangle fan defined by points (first vertex is the center)
	DrawTriangleFan: { parameters: ["pointer", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a triangle strip defined by points
	DrawTriangleStrip: { parameters: ["pointer", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a regular polygon (Vector version)
	DrawPoly: { parameters: ["buffer", "i32", "f32", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a polygon outline of n sides
	DrawPolyLines: { parameters: ["buffer", "i32", "f32", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a polygon outline of n sides with extended parameters
	DrawPolyLinesEx: { parameters: ["buffer", "i32", "f32", "f32", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw spline: Linear, minimum 2 points
	DrawSplineLinear: { parameters: ["pointer", "i32", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw spline: B-Spline, minimum 4 points
	DrawSplineBasis: { parameters: ["pointer", "i32", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw spline: Catmull-Rom, minimum 4 points
	DrawSplineCatmullRom: { parameters: ["pointer", "i32", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw spline segment: Linear, 2 points
	DrawSplineSegmentLinear: { parameters: ["buffer", "buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw spline segment: B-Spline, 4 points
	DrawSplineSegmentBasis: { parameters: ["buffer", "buffer", "buffer", "buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw spline segment: Catmull-Rom, 4 points
	DrawSplineSegmentCatmullRom: { parameters: ["buffer", "buffer", "buffer", "buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw spline segment: Quadratic Bezier, 2 points, 1 control point
	DrawSplineSegmentBezierQuadratic: { parameters: ["buffer", "buffer", "buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw spline segment: Cubic Bezier, 2 points, 2 control points
	DrawSplineSegmentBezierCubic: { parameters: ["buffer", "buffer", "buffer", "buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Get (evaluate) spline point: Linear
	GetSplinePointLinear: { parameters: ["buffer", "buffer", "f32"], result: "buffer" },
	// Get (evaluate) spline point: B-Spline
	GetSplinePointBasis: { parameters: ["buffer", "buffer", "buffer", "buffer", "f32"], result: "buffer" },
	// Get (evaluate) spline point: Catmull-Rom
	GetSplinePointCatmullRom: { parameters: ["buffer", "buffer", "buffer", "buffer", "f32"], result: "buffer" },
	// Get (evaluate) spline point: Quadratic Bezier
	GetSplinePointBezierQuad: { parameters: ["buffer", "buffer", "buffer", "f32"], result: "buffer" },
	// Get (evaluate) spline point: Cubic Bezier
	GetSplinePointBezierCubic: { parameters: ["buffer", "buffer", "buffer", "buffer", "f32"], result: "buffer" },
	// Check collision between two rectangles
	CheckCollisionRecs: { parameters: ["buffer", "buffer"], result: "u8" },
	// Check collision between two circles
	CheckCollisionCircles: { parameters: ["buffer", "f32", "buffer", "f32"], result: "u8" },
	// Check collision between circle and rectangle
	CheckCollisionCircleRec: { parameters: ["buffer", "f32", "buffer"], result: "u8" },
	// Check if point is inside rectangle
	CheckCollisionPointRec: { parameters: ["buffer", "buffer"], result: "u8" },
	// Check if point is inside circle
	CheckCollisionPointCircle: { parameters: ["buffer", "buffer", "f32"], result: "u8" },
	// Check if point is inside a triangle
	CheckCollisionPointTriangle: { parameters: ["buffer", "buffer", "buffer", "buffer"], result: "u8" },
	// Check if point is within a polygon described by array of vertices
	CheckCollisionPointPoly: { parameters: ["buffer", "pointer", "i32"], result: "u8" },
	// Check the collision between two lines defined by two points each, returns collision point by reference
	CheckCollisionLines: { parameters: ["buffer", "buffer", "buffer", "buffer", "pointer"], result: "u8" },
	// Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]
	CheckCollisionPointLine: { parameters: ["buffer", "buffer", "buffer", "i32"], result: "u8" },
	// Get collision rectangle for two rectangles collision
	GetCollisionRec: { parameters: ["buffer", "buffer"], result: "buffer" },
	// Load image from file into CPU memory (RAM)
	LoadImage: { parameters: ["buffer"], result: "buffer" },
	// Load image from RAW file data
	LoadImageRaw: { parameters: ["buffer", "i32", "i32", "i32", "i32"], result: "buffer" },
	// Load image from SVG file data or string with specified size
	LoadImageSvg: { parameters: ["buffer", "i32", "i32"], result: "buffer" },
	// Load image sequence from file (frames appended to image.data)
	LoadImageAnim: { parameters: ["buffer", "pointer"], result: "buffer" },
	// Load image from memory buffer, fileType refers to extension: i.e. '.png'
	LoadImageFromMemory: { parameters: ["buffer", "buffer", "i32"], result: "buffer" },
	// Load image from GPU texture data
	LoadImageFromTexture: { parameters: ["buffer"], result: "buffer" },
	// Load image from screen buffer and (screenshot)
	LoadImageFromScreen: { parameters: [], result: "buffer" },
	// Check if an image is ready
	IsImageReady: { parameters: ["buffer"], result: "u8" },
	// Unload image from CPU memory (RAM)
	UnloadImage: { parameters: ["buffer"], result: "void" },
	// Export image data to file, returns true on success
	ExportImage: { parameters: ["buffer", "buffer"], result: "u8" },
	// Export image to memory buffer
	ExportImageToMemory: { parameters: ["buffer", "buffer", "pointer"], result: "buffer" },
	// Export image as code file defining an array of bytes, returns true on success
	ExportImageAsCode: { parameters: ["buffer", "buffer"], result: "u8" },
	// Generate image: plain color
	GenImageColor: { parameters: ["i32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "buffer" },
	// Generate image: linear gradient, direction in degrees [0..360], 0=Vertical gradient
	GenImageGradientLinear: { parameters: ["i32", "i32", "i32", {"struct":["u8","u8","u8","u8"]}, {"struct":["u8","u8","u8","u8"]}], result: "buffer" },
	// Generate image: radial gradient
	GenImageGradientRadial: { parameters: ["i32", "i32", "f32", {"struct":["u8","u8","u8","u8"]}, {"struct":["u8","u8","u8","u8"]}], result: "buffer" },
	// Generate image: square gradient
	GenImageGradientSquare: { parameters: ["i32", "i32", "f32", {"struct":["u8","u8","u8","u8"]}, {"struct":["u8","u8","u8","u8"]}], result: "buffer" },
	// Generate image: checked
	GenImageChecked: { parameters: ["i32", "i32", "i32", "i32", {"struct":["u8","u8","u8","u8"]}, {"struct":["u8","u8","u8","u8"]}], result: "buffer" },
	// Generate image: white noise
	GenImageWhiteNoise: { parameters: ["i32", "i32", "f32"], result: "buffer" },
	// Generate image: perlin noise
	GenImagePerlinNoise: { parameters: ["i32", "i32", "i32", "i32", "f32"], result: "buffer" },
	// Generate image: cellular algorithm, bigger tileSize means bigger cells
	GenImageCellular: { parameters: ["i32", "i32", "i32"], result: "buffer" },
	// Generate image: grayscale image from text data
	GenImageText: { parameters: ["i32", "i32", "buffer"], result: "buffer" },
	// Create an image duplicate (useful for transformations)
	ImageCopy: { parameters: ["buffer"], result: "buffer" },
	// Create an image from another image piece
	ImageFromImage: { parameters: ["buffer", "buffer"], result: "buffer" },
	// Create an image from text (default font)
	ImageText: { parameters: ["buffer", "i32", {"struct":["u8","u8","u8","u8"]}], result: "buffer" },
	// Create an image from text (custom sprite font)
	ImageTextEx: { parameters: ["buffer", "buffer", "f32", "f32", {"struct":["u8","u8","u8","u8"]}], result: "buffer" },
	// Convert image data to desired format
	ImageFormat: { parameters: ["pointer", "i32"], result: "void" },
	// Convert image to POT (power-of-two)
	ImageToPOT: { parameters: ["pointer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Crop an image to a defined rectangle
	ImageCrop: { parameters: ["pointer", "buffer"], result: "void" },
	// Crop image depending on alpha value
	ImageAlphaCrop: { parameters: ["pointer", "f32"], result: "void" },
	// Clear alpha channel to desired color
	ImageAlphaClear: { parameters: ["pointer", {"struct":["u8","u8","u8","u8"]}, "f32"], result: "void" },
	// Apply alpha mask to image
	ImageAlphaMask: { parameters: ["pointer", "buffer"], result: "void" },
	// Premultiply alpha channel
	ImageAlphaPremultiply: { parameters: ["pointer"], result: "void" },
	// Apply Gaussian blur using a box blur approximation
	ImageBlurGaussian: { parameters: ["pointer", "i32"], result: "void" },
	// Resize image (Bicubic scaling algorithm)
	ImageResize: { parameters: ["pointer", "i32", "i32"], result: "void" },
	// Resize image (Nearest-Neighbor scaling algorithm)
	ImageResizeNN: { parameters: ["pointer", "i32", "i32"], result: "void" },
	// Resize canvas and fill with color
	ImageResizeCanvas: { parameters: ["pointer", "i32", "i32", "i32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Compute all mipmap levels for a provided image
	ImageMipmaps: { parameters: ["pointer"], result: "void" },
	// Dither image data to 16bpp or lower (Floyd-Steinberg dithering)
	ImageDither: { parameters: ["pointer", "i32", "i32", "i32", "i32"], result: "void" },
	// Flip image vertically
	ImageFlipVertical: { parameters: ["pointer"], result: "void" },
	// Flip image horizontally
	ImageFlipHorizontal: { parameters: ["pointer"], result: "void" },
	// Rotate image by input angle in degrees (-359 to 359)
	ImageRotate: { parameters: ["pointer", "i32"], result: "void" },
	// Rotate image clockwise 90deg
	ImageRotateCW: { parameters: ["pointer"], result: "void" },
	// Rotate image counter-clockwise 90deg
	ImageRotateCCW: { parameters: ["pointer"], result: "void" },
	// Modify image color: tint
	ImageColorTint: { parameters: ["pointer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Modify image color: invert
	ImageColorInvert: { parameters: ["pointer"], result: "void" },
	// Modify image color: grayscale
	ImageColorGrayscale: { parameters: ["pointer"], result: "void" },
	// Modify image color: contrast (-100 to 100)
	ImageColorContrast: { parameters: ["pointer", "f32"], result: "void" },
	// Modify image color: brightness (-255 to 255)
	ImageColorBrightness: { parameters: ["pointer", "i32"], result: "void" },
	// Modify image color: replace color
	ImageColorReplace: { parameters: ["pointer", {"struct":["u8","u8","u8","u8"]}, {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Load color data from image as a Color array (RGBA - 32bit)
	LoadImageColors: { parameters: ["buffer"], result: "pointer" },
	// Load colors palette from image as a Color array (RGBA - 32bit)
	LoadImagePalette: { parameters: ["buffer", "i32", "pointer"], result: "pointer" },
	// Unload color data loaded with LoadImageColors()
	UnloadImageColors: { parameters: ["pointer"], result: "void" },
	// Unload colors palette loaded with LoadImagePalette()
	UnloadImagePalette: { parameters: ["pointer"], result: "void" },
	// Get image alpha border rectangle
	GetImageAlphaBorder: { parameters: ["buffer", "f32"], result: "buffer" },
	// Get image pixel color at (x, y) position
	GetImageColor: { parameters: ["buffer", "i32", "i32"], result: {"struct":["u8","u8","u8","u8"]} },
	// Clear image background with given color
	ImageClearBackground: { parameters: ["pointer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw pixel within an image
	ImageDrawPixel: { parameters: ["pointer", "i32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw pixel within an image (Vector version)
	ImageDrawPixelV: { parameters: ["pointer", "buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw line within an image
	ImageDrawLine: { parameters: ["pointer", "i32", "i32", "i32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw line within an image (Vector version)
	ImageDrawLineV: { parameters: ["pointer", "buffer", "buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a filled circle within an image
	ImageDrawCircle: { parameters: ["pointer", "i32", "i32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a filled circle within an image (Vector version)
	ImageDrawCircleV: { parameters: ["pointer", "buffer", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw circle outline within an image
	ImageDrawCircleLines: { parameters: ["pointer", "i32", "i32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw circle outline within an image (Vector version)
	ImageDrawCircleLinesV: { parameters: ["pointer", "buffer", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw rectangle within an image
	ImageDrawRectangle: { parameters: ["pointer", "i32", "i32", "i32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw rectangle within an image (Vector version)
	ImageDrawRectangleV: { parameters: ["pointer", "buffer", "buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw rectangle within an image
	ImageDrawRectangleRec: { parameters: ["pointer", "buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw rectangle lines within an image
	ImageDrawRectangleLines: { parameters: ["pointer", "buffer", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a source image within a destination image (tint applied to source)
	ImageDraw: { parameters: ["pointer", "buffer", "buffer", "buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw text (using default font) within an image (destination)
	ImageDrawText: { parameters: ["pointer", "buffer", "i32", "i32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw text (custom sprite font) within an image (destination)
	ImageDrawTextEx: { parameters: ["pointer", "buffer", "buffer", "buffer", "f32", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Load texture from file into GPU memory (VRAM)
	LoadTexture: { parameters: ["buffer"], result: "buffer" },
	// Load texture from image data
	LoadTextureFromImage: { parameters: ["buffer"], result: "buffer" },
	// Load cubemap from image, multiple image cubemap layouts supported
	LoadTextureCubemap: { parameters: ["buffer", "i32"], result: "buffer" },
	// Load texture for rendering (framebuffer)
	LoadRenderTexture: { parameters: ["i32", "i32"], result: "buffer" },
	// Check if a texture is ready
	IsTextureReady: { parameters: ["buffer"], result: "u8" },
	// Unload texture from GPU memory (VRAM)
	UnloadTexture: { parameters: ["buffer"], result: "void" },
	// Check if a render texture is ready
	IsRenderTextureReady: { parameters: ["buffer"], result: "u8" },
	// Unload render texture from GPU memory (VRAM)
	UnloadRenderTexture: { parameters: ["buffer"], result: "void" },
	// Update GPU texture with new data
	UpdateTexture: { parameters: ["buffer", "buffer"], result: "void" },
	// Update GPU texture rectangle with new data
	UpdateTextureRec: { parameters: ["buffer", "buffer", "buffer"], result: "void" },
	// Generate GPU mipmaps for a texture
	GenTextureMipmaps: { parameters: ["pointer"], result: "void" },
	// Set texture scaling filter mode
	SetTextureFilter: { parameters: ["buffer", "i32"], result: "void" },
	// Set texture wrapping mode
	SetTextureWrap: { parameters: ["buffer", "i32"], result: "void" },
	// Draw a Texture2D
	DrawTexture: { parameters: ["buffer", "i32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a Texture2D with position defined as Vector2
	DrawTextureV: { parameters: ["buffer", "buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a Texture2D with extended parameters
	DrawTextureEx: { parameters: ["buffer", "buffer", "f32", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a part of a texture defined by a rectangle
	DrawTextureRec: { parameters: ["buffer", "buffer", "buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a part of a texture defined by a rectangle with 'pro' parameters
	DrawTexturePro: { parameters: ["buffer", "buffer", "buffer", "buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draws a texture (or part of it) that stretches or shrinks nicely
	DrawTextureNPatch: { parameters: ["buffer", "buffer", "buffer", "buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Get color with alpha applied, alpha goes from 0.0f to 1.0f
	Fade: { parameters: [{"struct":["u8","u8","u8","u8"]}, "f32"], result: {"struct":["u8","u8","u8","u8"]} },
	// Get hexadecimal value for a Color
	ColorToInt: { parameters: [{"struct":["u8","u8","u8","u8"]}], result: "i32" },
	// Get Color normalized as float [0..1]
	ColorNormalize: { parameters: [{"struct":["u8","u8","u8","u8"]}], result: "buffer" },
	// Get Color from normalized values [0..1]
	ColorFromNormalized: { parameters: ["buffer"], result: {"struct":["u8","u8","u8","u8"]} },
	// Get HSV values for a Color, hue [0..360], saturation/value [0..1]
	ColorToHSV: { parameters: [{"struct":["u8","u8","u8","u8"]}], result: "buffer" },
	// Get a Color from HSV values, hue [0..360], saturation/value [0..1]
	ColorFromHSV: { parameters: ["f32", "f32", "f32"], result: {"struct":["u8","u8","u8","u8"]} },
	// Get color multiplied with another color
	ColorTint: { parameters: [{"struct":["u8","u8","u8","u8"]}, {"struct":["u8","u8","u8","u8"]}], result: {"struct":["u8","u8","u8","u8"]} },
	// Get color with brightness correction, brightness factor goes from -1.0f to 1.0f
	ColorBrightness: { parameters: [{"struct":["u8","u8","u8","u8"]}, "f32"], result: {"struct":["u8","u8","u8","u8"]} },
	// Get color with contrast correction, contrast values between -1.0f and 1.0f
	ColorContrast: { parameters: [{"struct":["u8","u8","u8","u8"]}, "f32"], result: {"struct":["u8","u8","u8","u8"]} },
	// Get color with alpha applied, alpha goes from 0.0f to 1.0f
	ColorAlpha: { parameters: [{"struct":["u8","u8","u8","u8"]}, "f32"], result: {"struct":["u8","u8","u8","u8"]} },
	// Get src alpha-blended into dst color with tint
	ColorAlphaBlend: { parameters: [{"struct":["u8","u8","u8","u8"]}, {"struct":["u8","u8","u8","u8"]}, {"struct":["u8","u8","u8","u8"]}], result: {"struct":["u8","u8","u8","u8"]} },
	// Get Color structure from hexadecimal value
	GetColor: { parameters: ["u32"], result: {"struct":["u8","u8","u8","u8"]} },
	// Get Color from a source pixel pointer of certain format
	GetPixelColor: { parameters: ["pointer", "i32"], result: {"struct":["u8","u8","u8","u8"]} },
	// Set color formatted into destination pixel pointer
	SetPixelColor: { parameters: ["pointer", {"struct":["u8","u8","u8","u8"]}, "i32"], result: "void" },
	// Get pixel data size in bytes for certain format
	GetPixelDataSize: { parameters: ["i32", "i32", "i32"], result: "i32" },
	// Get the default Font
	GetFontDefault: { parameters: [], result: "buffer" },
	// Load font from file into GPU memory (VRAM)
	LoadFont: { parameters: ["buffer"], result: "buffer" },
	// Load font from file with extended parameters, use NULL for codepoints and 0 for codepointCount to load the default character set
	LoadFontEx: { parameters: ["buffer", "i32", "pointer", "i32"], result: "buffer" },
	// Load font from Image (XNA style)
	LoadFontFromImage: { parameters: ["buffer", {"struct":["u8","u8","u8","u8"]}, "i32"], result: "buffer" },
	// Load font from memory buffer, fileType refers to extension: i.e. '.ttf'
	LoadFontFromMemory: { parameters: ["buffer", "buffer", "i32", "i32", "pointer", "i32"], result: "buffer" },
	// Check if a font is ready
	IsFontReady: { parameters: ["buffer"], result: "u8" },
	// Load font data for further use
	LoadFontData: { parameters: ["buffer", "i32", "i32", "pointer", "i32", "i32"], result: "pointer" },
	// Generate image font atlas using chars info
	GenImageFontAtlas: { parameters: ["pointer", "pointer", "i32", "i32", "i32", "i32"], result: "buffer" },
	// Unload font chars info data (RAM)
	UnloadFontData: { parameters: ["pointer", "i32"], result: "void" },
	// Unload font from GPU memory (VRAM)
	UnloadFont: { parameters: ["buffer"], result: "void" },
	// Export font as code file, returns true on success
	ExportFontAsCode: { parameters: ["buffer", "buffer"], result: "u8" },
	// Draw current FPS
	DrawFPS: { parameters: ["i32", "i32"], result: "void" },
	// Draw text (using default font)
	DrawText: { parameters: ["buffer", "i32", "i32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw text using font and additional parameters
	DrawTextEx: { parameters: ["buffer", "buffer", "buffer", "f32", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw text using Font and pro parameters (rotation)
	DrawTextPro: { parameters: ["buffer", "buffer", "buffer", "buffer", "f32", "f32", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw one character (codepoint)
	DrawTextCodepoint: { parameters: ["buffer", "i32", "buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw multiple character (codepoint)
	DrawTextCodepoints: { parameters: ["buffer", "pointer", "i32", "buffer", "f32", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Set vertical line spacing when drawing with line-breaks
	SetTextLineSpacing: { parameters: ["i32"], result: "void" },
	// Measure string width for default font
	MeasureText: { parameters: ["buffer", "i32"], result: "i32" },
	// Measure string size for Font
	MeasureTextEx: { parameters: ["buffer", "buffer", "f32", "f32"], result: "buffer" },
	// Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found
	GetGlyphIndex: { parameters: ["buffer", "i32"], result: "i32" },
	// Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found
	GetGlyphInfo: { parameters: ["buffer", "i32"], result: "buffer" },
	// Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found
	GetGlyphAtlasRec: { parameters: ["buffer", "i32"], result: "buffer" },
	// Load UTF-8 text encoded from codepoints array
	LoadUTF8: { parameters: ["pointer", "i32"], result: "buffer" },
	// Unload UTF-8 text encoded from codepoints array
	UnloadUTF8: { parameters: ["buffer"], result: "void" },
	// Load all codepoints from a UTF-8 text string, codepoints count returned by parameter
	LoadCodepoints: { parameters: ["buffer", "pointer"], result: "pointer" },
	// Unload codepoints data from memory
	UnloadCodepoints: { parameters: ["pointer"], result: "void" },
	// Get total number of codepoints in a UTF-8 encoded string
	GetCodepointCount: { parameters: ["buffer"], result: "i32" },
	// Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
	GetCodepoint: { parameters: ["buffer", "pointer"], result: "i32" },
	// Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
	GetCodepointNext: { parameters: ["buffer", "pointer"], result: "i32" },
	// Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
	GetCodepointPrevious: { parameters: ["buffer", "pointer"], result: "i32" },
	// Encode one codepoint into UTF-8 byte array (array length returned as parameter)
	CodepointToUTF8: { parameters: ["i32", "pointer"], result: "buffer" },
	// Copy one string to another, returns bytes copied
	TextCopy: { parameters: ["buffer", "buffer"], result: "i32" },
	// Check if two text string are equal
	TextIsEqual: { parameters: ["buffer", "buffer"], result: "u8" },
	// Get text length, checks for '\0' ending
	TextLength: { parameters: ["buffer"], result: "u32" },
	// Get a piece of a text string
	TextSubtext: { parameters: ["buffer", "i32", "i32"], result: "buffer" },
	// Replace text string (WARNING: memory must be freed!)
	TextReplace: { parameters: ["buffer", "buffer", "buffer"], result: "buffer" },
	// Insert text in a position (WARNING: memory must be freed!)
	TextInsert: { parameters: ["buffer", "buffer", "i32"], result: "buffer" },
	// Join text strings with delimiter
	TextJoin: { parameters: ["buffer", "i32", "buffer"], result: "buffer" },
	// Split text into multiple strings
	TextSplit: { parameters: ["buffer", "i8", "pointer"], result: "buffer" },
	// Append text at specific position and move cursor!
	TextAppend: { parameters: ["buffer", "buffer", "pointer"], result: "void" },
	// Find first text occurrence within a string
	TextFindIndex: { parameters: ["buffer", "buffer"], result: "i32" },
	// Get upper case version of provided string
	TextToUpper: { parameters: ["buffer"], result: "buffer" },
	// Get lower case version of provided string
	TextToLower: { parameters: ["buffer"], result: "buffer" },
	// Get Pascal case notation version of provided string
	TextToPascal: { parameters: ["buffer"], result: "buffer" },
	// Get integer value from text (negative values not supported)
	TextToInteger: { parameters: ["buffer"], result: "i32" },
	// Draw a line in 3D world space
	DrawLine3D: { parameters: ["buffer", "buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a point in 3D space, actually a small line
	DrawPoint3D: { parameters: ["buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a circle in 3D world space
	DrawCircle3D: { parameters: ["buffer", "f32", "buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a color-filled triangle (vertex in counter-clockwise order!)
	DrawTriangle3D: { parameters: ["buffer", "buffer", "buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a triangle strip defined by points
	DrawTriangleStrip3D: { parameters: ["pointer", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw cube
	DrawCube: { parameters: ["buffer", "f32", "f32", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw cube (Vector version)
	DrawCubeV: { parameters: ["buffer", "buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw cube wires
	DrawCubeWires: { parameters: ["buffer", "f32", "f32", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw cube wires (Vector version)
	DrawCubeWiresV: { parameters: ["buffer", "buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw sphere
	DrawSphere: { parameters: ["buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw sphere with extended parameters
	DrawSphereEx: { parameters: ["buffer", "f32", "i32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw sphere wires
	DrawSphereWires: { parameters: ["buffer", "f32", "i32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a cylinder/cone
	DrawCylinder: { parameters: ["buffer", "f32", "f32", "f32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a cylinder with base at startPos and top at endPos
	DrawCylinderEx: { parameters: ["buffer", "buffer", "f32", "f32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a cylinder/cone wires
	DrawCylinderWires: { parameters: ["buffer", "f32", "f32", "f32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a cylinder wires with base at startPos and top at endPos
	DrawCylinderWiresEx: { parameters: ["buffer", "buffer", "f32", "f32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a capsule with the center of its sphere caps at startPos and endPos
	DrawCapsule: { parameters: ["buffer", "buffer", "f32", "i32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw capsule wireframe with the center of its sphere caps at startPos and endPos
	DrawCapsuleWires: { parameters: ["buffer", "buffer", "f32", "i32", "i32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a plane XZ
	DrawPlane: { parameters: ["buffer", "buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a ray line
	DrawRay: { parameters: ["buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a grid (centered at (0, 0, 0))
	DrawGrid: { parameters: ["i32", "f32"], result: "void" },
	// Load model from files (meshes and materials)
	LoadModel: { parameters: ["buffer"], result: "buffer" },
	// Load model from generated mesh (default material)
	LoadModelFromMesh: { parameters: ["buffer"], result: "buffer" },
	// Check if a model is ready
	IsModelReady: { parameters: ["buffer"], result: "u8" },
	// Unload model (including meshes) from memory (RAM and/or VRAM)
	UnloadModel: { parameters: ["buffer"], result: "void" },
	// Compute model bounding box limits (considers all meshes)
	GetModelBoundingBox: { parameters: ["buffer"], result: "buffer" },
	// Draw a model (with texture if set)
	DrawModel: { parameters: ["buffer", "buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a model with extended parameters
	DrawModelEx: { parameters: ["buffer", "buffer", "buffer", "f32", "buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a model wires (with texture if set)
	DrawModelWires: { parameters: ["buffer", "buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a model wires (with texture if set) with extended parameters
	DrawModelWiresEx: { parameters: ["buffer", "buffer", "buffer", "f32", "buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw bounding box (wires)
	DrawBoundingBox: { parameters: ["buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a billboard texture
	DrawBillboard: { parameters: ["buffer", "buffer", "buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a billboard texture defined by source
	DrawBillboardRec: { parameters: ["buffer", "buffer", "buffer", "buffer", "buffer", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Draw a billboard texture defined by source and rotation
	DrawBillboardPro: { parameters: ["buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "buffer", "f32", {"struct":["u8","u8","u8","u8"]}], result: "void" },
	// Upload mesh vertex data in GPU and provide VAO/VBO ids
	UploadMesh: { parameters: ["pointer", "u8"], result: "void" },
	// Update mesh vertex data in GPU for a specific buffer index
	UpdateMeshBuffer: { parameters: ["buffer", "i32", "buffer", "i32", "i32"], result: "void" },
	// Unload mesh data from CPU and GPU
	UnloadMesh: { parameters: ["buffer"], result: "void" },
	// Draw a 3d mesh with material and transform
	DrawMesh: { parameters: ["buffer", "buffer", "buffer"], result: "void" },
	// Draw multiple mesh instances with material and different transforms
	DrawMeshInstanced: { parameters: ["buffer", "buffer", "buffer", "i32"], result: "void" },
	// Export mesh data to file, returns true on success
	ExportMesh: { parameters: ["buffer", "buffer"], result: "u8" },
	// Compute mesh bounding box limits
	GetMeshBoundingBox: { parameters: ["buffer"], result: "buffer" },
	// Compute mesh tangents
	GenMeshTangents: { parameters: ["pointer"], result: "void" },
	// Generate polygonal mesh
	GenMeshPoly: { parameters: ["i32", "f32"], result: "buffer" },
	// Generate plane mesh (with subdivisions)
	GenMeshPlane: { parameters: ["f32", "f32", "i32", "i32"], result: "buffer" },
	// Generate cuboid mesh
	GenMeshCube: { parameters: ["f32", "f32", "f32"], result: "buffer" },
	// Generate sphere mesh (standard sphere)
	GenMeshSphere: { parameters: ["f32", "i32", "i32"], result: "buffer" },
	// Generate half-sphere mesh (no bottom cap)
	GenMeshHemiSphere: { parameters: ["f32", "i32", "i32"], result: "buffer" },
	// Generate cylinder mesh
	GenMeshCylinder: { parameters: ["f32", "f32", "i32"], result: "buffer" },
	// Generate cone/pyramid mesh
	GenMeshCone: { parameters: ["f32", "f32", "i32"], result: "buffer" },
	// Generate torus mesh
	GenMeshTorus: { parameters: ["f32", "f32", "i32", "i32"], result: "buffer" },
	// Generate trefoil knot mesh
	GenMeshKnot: { parameters: ["f32", "f32", "i32", "i32"], result: "buffer" },
	// Generate heightmap mesh from image data
	GenMeshHeightmap: { parameters: ["buffer", "buffer"], result: "buffer" },
	// Generate cubes-based map mesh from image data
	GenMeshCubicmap: { parameters: ["buffer", "buffer"], result: "buffer" },
	// Load materials from model file
	LoadMaterials: { parameters: ["buffer", "pointer"], result: "pointer" },
	// Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)
	LoadMaterialDefault: { parameters: [], result: "buffer" },
	// Check if a material is ready
	IsMaterialReady: { parameters: ["buffer"], result: "u8" },
	// Unload material from GPU memory (VRAM)
	UnloadMaterial: { parameters: ["buffer"], result: "void" },
	// Set material for a mesh
	SetModelMeshMaterial: { parameters: ["pointer", "i32", "i32"], result: "void" },
	// Load model animations from file
	LoadModelAnimations: { parameters: ["buffer", "pointer"], result: "pointer" },
	// Update model animation pose
	UpdateModelAnimation: { parameters: ["buffer", "buffer", "i32"], result: "void" },
	// Unload animation data
	UnloadModelAnimation: { parameters: ["buffer"], result: "void" },
	// Unload animation array data
	UnloadModelAnimations: { parameters: ["pointer", "i32"], result: "void" },
	// Check model animation skeleton match
	IsModelAnimationValid: { parameters: ["buffer", "buffer"], result: "u8" },
	// Check collision between two spheres
	CheckCollisionSpheres: { parameters: ["buffer", "f32", "buffer", "f32"], result: "u8" },
	// Check collision between two bounding boxes
	CheckCollisionBoxes: { parameters: ["buffer", "buffer"], result: "u8" },
	// Check collision between box and sphere
	CheckCollisionBoxSphere: { parameters: ["buffer", "buffer", "f32"], result: "u8" },
	// Get collision info between ray and sphere
	GetRayCollisionSphere: { parameters: ["buffer", "buffer", "f32"], result: "buffer" },
	// Get collision info between ray and box
	GetRayCollisionBox: { parameters: ["buffer", "buffer"], result: "buffer" },
	// Get collision info between ray and mesh
	GetRayCollisionMesh: { parameters: ["buffer", "buffer", "buffer"], result: "buffer" },
	// Get collision info between ray and triangle
	GetRayCollisionTriangle: { parameters: ["buffer", "buffer", "buffer", "buffer"], result: "buffer" },
	// Get collision info between ray and quad
	GetRayCollisionQuad: { parameters: ["buffer", "buffer", "buffer", "buffer", "buffer"], result: "buffer" },
	// Initialize audio device and context
	InitAudioDevice: { parameters: [], result: "void" },
	// Close the audio device and context
	CloseAudioDevice: { parameters: [], result: "void" },
	// Check if audio device has been initialized successfully
	IsAudioDeviceReady: { parameters: [], result: "u8" },
	// Set master volume (listener)
	SetMasterVolume: { parameters: ["f32"], result: "void" },
	// Get master volume (listener)
	GetMasterVolume: { parameters: [], result: "f32" },
	// Load wave data from file
	LoadWave: { parameters: ["buffer"], result: "buffer" },
	// Load wave from memory buffer, fileType refers to extension: i.e. '.wav'
	LoadWaveFromMemory: { parameters: ["buffer", "buffer", "i32"], result: "buffer" },
	// Checks if wave data is ready
	IsWaveReady: { parameters: ["buffer"], result: "u8" },
	// Load sound from file
	LoadSound: { parameters: ["buffer"], result: "buffer" },
	// Load sound from wave data
	LoadSoundFromWave: { parameters: ["buffer"], result: "buffer" },
	// Create a new sound that shares the same sample data as the source sound, does not own the sound data
	LoadSoundAlias: { parameters: ["buffer"], result: "buffer" },
	// Checks if a sound is ready
	IsSoundReady: { parameters: ["buffer"], result: "u8" },
	// Update sound buffer with new data
	UpdateSound: { parameters: ["buffer", "buffer", "i32"], result: "void" },
	// Unload wave data
	UnloadWave: { parameters: ["buffer"], result: "void" },
	// Unload sound
	UnloadSound: { parameters: ["buffer"], result: "void" },
	// Unload a sound alias (does not deallocate sample data)
	UnloadSoundAlias: { parameters: ["buffer"], result: "void" },
	// Export wave data to file, returns true on success
	ExportWave: { parameters: ["buffer", "buffer"], result: "u8" },
	// Export wave sample data to code (.h), returns true on success
	ExportWaveAsCode: { parameters: ["buffer", "buffer"], result: "u8" },
	// Play a sound
	PlaySound: { parameters: ["buffer"], result: "void" },
	// Stop playing a sound
	StopSound: { parameters: ["buffer"], result: "void" },
	// Pause a sound
	PauseSound: { parameters: ["buffer"], result: "void" },
	// Resume a paused sound
	ResumeSound: { parameters: ["buffer"], result: "void" },
	// Check if a sound is currently playing
	IsSoundPlaying: { parameters: ["buffer"], result: "u8" },
	// Set volume for a sound (1.0 is max level)
	SetSoundVolume: { parameters: ["buffer", "f32"], result: "void" },
	// Set pitch for a sound (1.0 is base level)
	SetSoundPitch: { parameters: ["buffer", "f32"], result: "void" },
	// Set pan for a sound (0.5 is center)
	SetSoundPan: { parameters: ["buffer", "f32"], result: "void" },
	// Copy a wave to a new wave
	WaveCopy: { parameters: ["buffer"], result: "buffer" },
	// Crop a wave to defined samples range
	WaveCrop: { parameters: ["pointer", "i32", "i32"], result: "void" },
	// Convert wave data to desired format
	WaveFormat: { parameters: ["pointer", "i32", "i32", "i32"], result: "void" },
	// Load samples data from wave as a 32bit float data array
	LoadWaveSamples: { parameters: ["buffer"], result: "buffer" },
	// Unload samples data loaded with LoadWaveSamples()
	UnloadWaveSamples: { parameters: ["buffer"], result: "void" },
	// Load music stream from file
	LoadMusicStream: { parameters: ["buffer"], result: "buffer" },
	// Load music stream from data
	LoadMusicStreamFromMemory: { parameters: ["buffer", "buffer", "i32"], result: "buffer" },
	// Checks if a music stream is ready
	IsMusicReady: { parameters: ["buffer"], result: "u8" },
	// Unload music stream
	UnloadMusicStream: { parameters: ["buffer"], result: "void" },
	// Start music playing
	PlayMusicStream: { parameters: ["buffer"], result: "void" },
	// Check if music is playing
	IsMusicStreamPlaying: { parameters: ["buffer"], result: "u8" },
	// Updates buffers for music streaming
	UpdateMusicStream: { parameters: ["buffer"], result: "void" },
	// Stop music playing
	StopMusicStream: { parameters: ["buffer"], result: "void" },
	// Pause music playing
	PauseMusicStream: { parameters: ["buffer"], result: "void" },
	// Resume playing paused music
	ResumeMusicStream: { parameters: ["buffer"], result: "void" },
	// Seek music to a position (in seconds)
	SeekMusicStream: { parameters: ["buffer", "f32"], result: "void" },
	// Set volume for music (1.0 is max level)
	SetMusicVolume: { parameters: ["buffer", "f32"], result: "void" },
	// Set pitch for a music (1.0 is base level)
	SetMusicPitch: { parameters: ["buffer", "f32"], result: "void" },
	// Set pan for a music (0.5 is center)
	SetMusicPan: { parameters: ["buffer", "f32"], result: "void" },
	// Get music time length (in seconds)
	GetMusicTimeLength: { parameters: ["buffer"], result: "f32" },
	// Get current music time played (in seconds)
	GetMusicTimePlayed: { parameters: ["buffer"], result: "f32" },
	// Load audio stream (to stream raw audio pcm data)
	LoadAudioStream: { parameters: ["u32", "u32", "u32"], result: "buffer" },
	// Checks if an audio stream is ready
	IsAudioStreamReady: { parameters: ["buffer"], result: "u8" },
	// Unload audio stream and free memory
	UnloadAudioStream: { parameters: ["buffer"], result: "void" },
	// Update audio stream buffers with data
	UpdateAudioStream: { parameters: ["buffer", "buffer", "i32"], result: "void" },
	// Check if any audio stream buffers requires refill
	IsAudioStreamProcessed: { parameters: ["buffer"], result: "u8" },
	// Play audio stream
	PlayAudioStream: { parameters: ["buffer"], result: "void" },
	// Pause audio stream
	PauseAudioStream: { parameters: ["buffer"], result: "void" },
	// Resume audio stream
	ResumeAudioStream: { parameters: ["buffer"], result: "void" },
	// Check if audio stream is playing
	IsAudioStreamPlaying: { parameters: ["buffer"], result: "u8" },
	// Stop audio stream
	StopAudioStream: { parameters: ["buffer"], result: "void" },
	// Set volume for audio stream (1.0 is max level)
	SetAudioStreamVolume: { parameters: ["buffer", "f32"], result: "void" },
	// Set pitch for audio stream (1.0 is base level)
	SetAudioStreamPitch: { parameters: ["buffer", "f32"], result: "void" },
	// Set pan for audio stream (0.5 is centered)
	SetAudioStreamPan: { parameters: ["buffer", "f32"], result: "void" },
	// Default size for new audio streams
	SetAudioStreamBufferSizeDefault: { parameters: ["i32"], result: "void" },
	// Audio thread callback to request new data
	SetAudioStreamCallback: { parameters: ["buffer", "function"], result: "void" },
	// Attach audio stream processor to stream, receives the samples as <float>s
	AttachAudioStreamProcessor: { parameters: ["buffer", "function"], result: "void" },
	// Detach audio stream processor from stream
	DetachAudioStreamProcessor: { parameters: ["buffer", "function"], result: "void" },
	// Attach audio stream processor to the entire audio pipeline, receives the samples as <float>s
	AttachAudioMixedProcessor: { parameters: ["function"], result: "void" },
	// Detach audio stream processor from the entire audio pipeline
	DetachAudioMixedProcessor: { parameters: ["function"], result: "void" },
});

